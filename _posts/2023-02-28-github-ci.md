---
layout: post
date: 2023-02-28 12:00:00 +00:00
title: Systemd Container and Podman in Github CI
description: How to run Systemd containers and/or podman runtime on github CI
permalink: blog/2023-02-28/systemd-podman-github-ci
tags:
- Programming
- Systemd
- D-Installer
- github-ci
- podman
---

As D-Installer consists of several components like dbus backend, CLI or web frontend,
we see a need for test ideally in CI that each component can properly start and
communicate each other. For it we use a testing framework and more importantly
github CI where we need systemd container which in the end is not documented at all.
In following paragraphs we would like to share with you how we did it so
anyone of you can inspire from it or use it for their own project.

## Testing Container

Lets start with container. We created in OBS testing container that includes what is needed for
backend and frontend. During iterations we found that we depends on Network Manager and network
manager works really tightly with systemd. For debugging failures we need journal that also does
not work without systemd. So we ends up creating container that contains systemd.

Such container has several restrictions like that first process has to be systemd init.

## Github CI

When asking uncle Google how to run such systemd container on github CI it returns nothing relevant.
There was also hint to use podman for such container due to its advanced support for it
( `--systemd` option which is by default true ). But for use podman majority of answers suggest
self-hosting workers, which is not what we want take care of.

Simple running of systemd container on github ci does not work as github overwrites entry point
to tail -f, so systemd is not the first process. Then we notice that on github hosted ubuntu
VM there is also podman preinstalled. And final idea how to solve it emerges and works for us.

## Github CI, Podman and Systemd Container

So idea is simple to run podman as steps in github CI and use our systemd container. We do not define
container keyword at all and run it manually. Each step is encapsulated in `podman container exec`.

Example config can look like:

```
  integration-tests:
    runs-on: ubuntu-latest

    steps:

    - name: Git Checkout
      uses: actions/checkout@v3

    - name: start container
      run: podman run --privileged --detach --name dinstaller --ipc=host -v .:/checkout registry.opensuse.org/yast/head/containers/containers_tumbleweed/opensuse/dinstaller-testing:latest

    - name: show journal
      run:  podman exec dinstaller journalctl -b
```

This simple snippet do checkout of github repo, start container and then print content of
journal. Important part is to set name of container, so you can use it in exec call. Also we mount
inside container git checkout, so we can access it from there. Of course real testing of container
is in front of you, but you already have running systemd container and can inspect logs from it.

## Remaining Issues

For integration testing of dinstaller we still facing some issues.

* *Different kernel* on ubuntu latest is different kernel and we e.g. face issue that device mapper
  kernel module is missing there.
* *Restricted permissions*. Not all actions even in privileged container is possible, but it seems
  so far we are not much limited with it. E.g. we cannot manipulate host /var/log, so we cannot
  simply mount host /var/log to container /var/log for easy recovery of logs to artifacts.
* *Cannot test whole installation* as whole installation is long and we do not want (and neither can)
  to overwrite host VM we cannot do full end to end testing of whole installation as part of each
  github pull request. Good news is that SUSE/openSUSE has great tool for testing
  installation/running system called openQA and we are discussing how to incorporate dinstaller with
  its test into it.
